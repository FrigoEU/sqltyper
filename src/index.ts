// tslint:disable:no-console
import { promises as fs } from 'fs'
import watch from 'node-watch'
import * as path from 'path'

import * as Either from 'fp-ts/lib/Either'
import * as Task from 'fp-ts/lib/Task'
import * as TaskEither from 'fp-ts/lib/TaskEither'
import { pipe } from 'fp-ts/lib/pipeable'
import * as yargs from 'yargs'

import { Clients, connect, disconnect } from './clients'
import { generateTypeScript, validateStatement } from './codegen'
import { describeStatement } from './describe'
import { inferStatementNullability } from './infer'
import { preprocessSQL } from './preprocess'
import { runPrettier } from './prettify'

async function main(): Promise<number> {
  const args = parseArgs()
  if (!args._.length) {
    console.error('No input files. Try with `--help`.')
    return 1
  }

  const dirPaths: string[] = []
  for (const dirPath of args._) {
    if (!(await fs.stat(dirPath)).isDirectory()) {
      console.error(`Not a directory: ${dirPath}`)
      return 1
    }
    dirPaths.push(dirPath)
  }
  const fileExtensions = extensions(args.ext)

  const clients = await connect(args.database)
  if (Either.isLeft(clients)) {
    console.error(clients.left)
    throw process.exit(1)
  }

  if (args.watch) {
    await watchDirectories(
      clients.right,
      fileExtensions,
      dirPaths,
      args.prettify
    )
  } else {
    await processDirectories(
      clients.right,
      fileExtensions,
      dirPaths,
      args.prettify
    )
  }

  await disconnect(clients.right)
  return 0
}

function parseArgs() {
  return yargs
    .usage('Usage: $0 [options] DIRECTORY...')
    .option('database', {
      alias: 'd',
      describe:
        'Database URI to connect to, e.g. -d postgres://user:pass@localhost/mydb',
      type: 'string',
    })
    .option('ext', {
      alias: 'e',
      default: 'sql',
      describe: 'File extensions to consider, e.g. -e sql,psql',
      type: 'string',
    })
    .option('watch', {
      alias: 'w',
      description: 'Watch files and run the conversion when something changes',
      type: 'boolean',
      default: false,
    })
    .option('prettify', {
      alias: 'p',
      description: 'Apply prettier to output TypeScript files',
      type: 'boolean',
      default: false,
    })
    .epilogue(
      `\
Generate TypeScript functions for SQL statements in all files in the \
given directories. For each input file, the output file name is \
generated by removing the file extension and appending ".ts".

Each output file will export a single function whose name is a \
camelCased version of the basename of the input file.

$0 connects to the database to infer the parameter and output column \
types of each SQL statement. It does this without actually executing \
the SQL queries, so it's safe to run against any database.
`
    )
    .help().argv
}

async function watchDirectories(
  clients: Clients,
  fileExtensions: string[],
  dirPaths: string[],
  prettify: boolean
) {
  await processDirectories(clients, fileExtensions, dirPaths, prettify)
  dirPaths.forEach(dirPath =>
    watch(
      dirPath,
      { filter: fileName => hasOneOfExtensions(fileExtensions, fileName) },
      async (event, filePath) => {
        switch (event) {
          case 'update':
            processSQLFile(clients, filePath, prettify)
            return
          case 'remove':
            removeOutputFile(filePath)
            return
        }
      }
    )
  )
  return new Promise(() => {})
}

async function processDirectories(
  clients: Clients,
  fileExtensions: string[],
  dirPaths: string[],
  prettify: boolean
) {
  for (const dirPath of dirPaths) {
    const success = await processDirectory(
      clients,
      dirPath,
      fileExtensions,
      prettify
    )
    if (!success) {
      break
    }
  }
}

async function processDirectory(
  clients: Clients,
  dirPath: string,
  fileExtensions: string[],
  prettify: boolean
): Promise<boolean> {
  for (const dirent of await fs.readdir(dirPath, {
    encoding: 'utf-8',
    withFileTypes: true,
  })) {
    if (!(await isSQLFile(fileExtensions, dirPath, dirent.name))) {
      continue
    }

    const filePath = path.join(dirPath, dirent.name)
    if (!(await processSQLFile(clients, filePath, prettify))) {
      return false
    }
  }
  return true
}

async function processSQLFile(
  clients: Clients,
  filePath: string,
  prettify: boolean
): Promise<boolean> {
  const tsPath = getOutputPath(filePath)
  console.log('---------------------------------------------------------')
  console.log(`${filePath} => ${tsPath}`)

  return Either.isRight(
    await pipe(
      Task.of(fs.readFile(filePath)),
      Task.map(s => s.toString()),
      Task.map(preprocessSQL),
      TaskEither.chain(processed =>
        describeStatement(clients.pg, processed.sql, processed.paramNames)
      ),
      TaskEither.chain(stmt => Task.of(validateStatement(stmt))),
      TaskEither.chain(stmt => inferStatementNullability(clients.schema, stmt)),
      TaskEither.map(stmt => generateTypeScript(clients.types, filePath, stmt)),
      TaskEither.chain(tsCode =>
        prettify
          ? TaskEither.rightTask(() =>
              runPrettier(getOutputPath(filePath), tsCode)
            )
          : TaskEither.right(tsCode)
      ),
      TaskEither.chain(tsCode => () =>
        fs.writeFile(tsPath, tsCode).then(Either.right)
      ),
      TaskEither.mapLeft(errorMessage => {
        console.error(errorMessage)
      })
    )()
  )
}

async function removeOutputFile(filePath: string): Promise<void> {
  const tsPath = getOutputPath(filePath)
  try {
    await fs.unlink(tsPath)
  } catch (_err) {
    return
  }
  console.log('---------------------------------------------------------')
  console.log(`Removed ${tsPath}`)
}

function getOutputPath(filePath: string): string {
  return path.format({
    ...path.parse(filePath),
    base: undefined,
    ext: '.ts',
  })
}

function extensions(e: string): string[] {
  return e.split(',').map(ext => `.${ext}`)
}

async function isSQLFile(
  extensions: string[],
  dirPath: string,
  fileName: string
) {
  let stats
  try {
    stats = await fs.stat(path.join(dirPath, fileName))
  } catch (_err) {
    return false
  }
  return stats.isFile() && hasOneOfExtensions(extensions, fileName)
}

function hasOneOfExtensions(exts: string[], fileName: string): boolean {
  return exts.includes(path.parse(fileName).ext)
}

main()
  .then(status => process.exit(status))
  .catch(err => {
    console.error(err)
    process.exit(99)
  })
