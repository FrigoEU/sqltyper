// tslint:disable:no-console
import { Dirent, promises as fs } from 'fs'
import { watch as fsWatch } from 'fs'
import * as path from 'path'

import * as Either from 'fp-ts/lib/Either'
import * as Task from 'fp-ts/lib/Task'
import * as TaskEither from 'fp-ts/lib/TaskEither'
import { pipe } from 'fp-ts/lib/pipeable'
import * as yargs from 'yargs'

import { Clients, connect, disconnect } from './clients'
import { generateTypeScript, validateStatement } from './codegen'
import { describeStatement } from './describe'
import { inferStatementNullability } from './infer'
import { preprocessSQL } from './preprocess'

async function main(): Promise<number> {
  const args = parseArgs()
  if (!args._.length) {
    console.error('No input files. Try with `--help`.')
    return 1
  }

  const dirPaths: string[] = []
  for (const dirPath of args._) {
    if (!(await fs.stat(dirPath)).isDirectory()) {
      console.error(`Not a directory: ${dirPath}`)
      return 1
    }
    dirPaths.push(dirPath)
  }
  const fileExtensions = extensions(args.e)

  const clients = await connect(args.d)
  if (Either.isLeft(clients)) {
    console.error(clients.left)
    throw process.exit(1)
  }

  if (args.w) {
    await watchDirectories(clients.right, fileExtensions, dirPaths)
  } else {
    await processDirectories(clients.right, fileExtensions, dirPaths)
  }

  await disconnect(clients.right)
  return 0
}

function parseArgs() {
  return yargs
    .usage('Usage: $0 [options] DIRECTORY...')
    .option('d', {
      alias: 'database',
      describe:
        'Database URI to connect to, e.g. -d postgres://user:pass@localhost/mydb',
      type: 'string',
    })
    .option('e', {
      alias: 'ext',
      default: 'sql',
      describe: 'File extensions to consider, e.g. -e sql,psql',
      type: 'string',
    })
    .option('w', {
      alias: 'watch',
      description: 'Watch files and run the conversion when something changes',
      type: 'boolean',
    })
    .epilogue(
      `\
Generate TypeScript functions for SQL statements in all files in the \
given directories. For each input file, the output file name is \
generated by removing the file extension and appending ".ts".

Each output file will export a single function whose name is a \
camelCased version of the basename of the input file.

$0 connects to the database to infer the parameter and output column \
types of each SQL statement. It does this without actually executing \
the SQL queries, so it's safe to run against any database.
`
    )
    .help().argv
}

async function watchDirectories(
  clients: Clients,
  fileExtensions: string[],
  dirPaths: string[]
) {
  await processDirectories(clients, fileExtensions, dirPaths)
  dirPaths.forEach(dirPath =>
    fsWatch(dirPath, async (_eventType, fileName) => {
      if (!(await isSQLFile(fileExtensions, dirPath, fileName))) {
        return
      }
      processSQLFile(clients, path.join(dirPath, fileName))
    })
  )
  return new Promise(() => {})
}

async function processDirectories(
  clients: Clients,
  fileExtensions: string[],
  dirPaths: string[]
) {
  for (const dirPath of dirPaths) {
    const success = await processDirectory(clients, dirPath, fileExtensions)
    if (!success) {
      break
    }
  }
}

async function processDirectory(
  clients: Clients,
  dirPath: string,
  fileExtensions: string[]
): Promise<boolean> {
  for (const dirent of await fs.readdir(dirPath, {
    encoding: 'utf-8',
    withFileTypes: true,
  })) {
    if (!(await isSQLFile(fileExtensions, dirPath, dirent.name))) {
      continue
    }

    const filePath = path.join(dirPath, dirent.name)
    if (!(await processSQLFile(clients, filePath))) {
      return false
    }
  }
  return true
}

async function processSQLFile(
  clients: Clients,
  filePath: string
): Promise<boolean> {
  const tsPath = getOutputPath(filePath)
  console.log('---------------------------------------------------------')
  console.log(`${filePath} => ${tsPath}`)

  return Either.isRight(
    await pipe(
      Task.of(fs.readFile(filePath)),
      Task.map(s => s.toString()),
      Task.map(preprocessSQL),
      TaskEither.chain(processed => () =>
        describeStatement(clients.pg, processed.sql, processed.paramNames)
      ),
      TaskEither.chain(stmt => Task.of(validateStatement(stmt))),
      TaskEither.chain(stmt => inferStatementNullability(clients.schema, stmt)),
      TaskEither.map(stmt => generateTypeScript(clients.types, filePath, stmt)),
      TaskEither.chain(tsCode => () =>
        fs.writeFile(tsPath, tsCode).then(Either.right)
      ),
      TaskEither.mapLeft(errorMessage => {
        console.error(errorMessage)
      })
    )()
  )
}

function getOutputPath(filePath: string): string {
  return path.format({
    ...path.parse(filePath),
    base: undefined,
    ext: '.ts',
  })
}

function extensions(e: string): string[] {
  return e.split(',').map(ext => `.${ext}`)
}

async function isSQLFile(
  extensions: string[],
  dirPath: string,
  fileName: string
) {
  let stats
  try {
    stats = await fs.stat(path.join(dirPath, fileName))
  } catch (_err) {
    return false
  }
  return stats.isFile() && hasOneOfExtensions(extensions, fileName)
}

function hasOneOfExtensions(exts: string[], fileName: string): boolean {
  return exts.includes(path.parse(fileName).ext)
}

main()
  .then(status => process.exit(status))
  .catch(err => {
    console.error(err)
    process.exit(99)
  })
