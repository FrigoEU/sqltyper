import { promises as fs, Dirent } from 'fs'
import * as path from 'path'

import * as Task from 'fp-ts/lib/Task'
import * as TaskEither from 'fp-ts/lib/TaskEither'
import * as Either from 'fp-ts/lib/Either'
import { pipe } from 'fp-ts/lib/pipeable'
import * as R from 'ramda'
import * as yargs from 'yargs'

import { Clients, connect, disconnect } from './clients'
import { preprocessSQL } from './preprocess'
import { inferStatementNullability } from './infer'
import { describeStatement } from './describe'
import { validateStatement, generateTypeScript } from './codegen'

async function main(): Promise<number> {
  const args = parseArgs()
  if (!args._.length) {
    console.error('No input files. Try with `--help`.')
    return 1
  }

  const dirPaths: string[] = []
  for (let dirPath of args._) {
    if (!(await fs.stat(dirPath)).isDirectory()) {
      console.error(`Not a directory: ${dirPath}`)
      return 1
    }
    dirPaths.push(dirPath)
  }
  const fileExtensions = extensions(args.e)

  const clients = await connect(args.d)
  if (Either.isLeft(clients)) {
    console.error(clients.left)
    throw process.exit(1)
  }

  for (let dirPath of dirPaths) {
    const success = await processDirectory(
      clients.right,
      dirPath,
      fileExtensions
    )
    if (!success) break
  }

  await disconnect(clients.right)
  return 0
}

function parseArgs() {
  return yargs
    .usage('Usage: $0 [options] DIRECTORY...')
    .option('d', {
      alias: 'database',
      type: 'string',
      describe:
        'Database URI to connect to, e.g. -d postgres://user:pass@localhost/mydb',
    })
    .option('e', {
      alias: 'ext',
      type: 'string',
      describe: 'File extensions to consider, e.g. -e sql,psql',
      default: 'sql',
    })
    .epilogue(
      `\
Generate TypeScript functions for SQL statements in all files in the \
given directories. For each input file, the output file name is \
generated by removing the file extension and appending ".ts".

Each output file will export a single function whose name is a \
camelCased version of the basename of the input file.

$0 connects to the database to infer the parameter and output column \
types of each SQL statement. It does this without actually executing \
the SQL queries, so it's safe to run against any database.
`
    )
    .help().argv
}

async function processDirectory(
  clients: Clients,
  dirPath: string,
  fileExtensions: string[]
): Promise<boolean> {
  for (const dirent of await fs.readdir(dirPath, {
    encoding: 'utf-8',
    withFileTypes: true,
  })) {
    if (!isSQLFile(fileExtensions, dirent)) continue

    const filePath = path.join(dirPath, dirent.name)
    if (!(await processSQLFile(clients, filePath))) return false
  }
  return true
}

async function processSQLFile(
  clients: Clients,
  filePath: string
): Promise<boolean> {
  const tsPath = getOutputPath(filePath)
  console.log('---------------------------------------------------------')
  console.log(`${filePath} => ${tsPath}`)

  return Either.isRight(
    await pipe(
      Task.of(fs.readFile(filePath)),
      Task.map(s => s.toString()),
      Task.map(preprocessSQL),
      TaskEither.chain(processed => () =>
        describeStatement(clients.pg, processed.sql, processed.paramNames)
      ),
      TaskEither.chain(stmt => Task.of(validateStatement(stmt))),
      TaskEither.chain(stmt => inferStatementNullability(clients.schema, stmt)),
      TaskEither.map(stmt => generateTypeScript(clients.types, filePath, stmt)),
      TaskEither.chain(tsCode => () =>
        fs.writeFile(tsPath, tsCode).then(Either.right)
      ),
      TaskEither.mapLeft(errorMessage => {
        console.error(errorMessage)
      })
    )()
  )
}

function isSQLFile(fileExtensions: string[], dirent: Dirent): boolean {
  return dirent.isFile() && hasOneOfExtensions(fileExtensions, dirent.name)
}

function getOutputPath(filePath: string): string {
  return path.format({
    ...path.parse(filePath),
    base: undefined,
    ext: '.ts',
  })
}

function extensions(e: string): string[] {
  return e.split(',').map(ext => `.${ext}`)
}

function hasOneOfExtensions(extensions: string[], fileName: string): boolean {
  return extensions.includes(path.parse(fileName).ext)
}

main()
  .then(status => process.exit(status))
  .catch(err => {
    console.error(err)
    process.exit(99)
  })
