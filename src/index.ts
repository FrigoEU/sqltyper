import { promises as fs } from 'fs'
import * as path from 'path'

import { chain, isRight } from 'fp-ts/lib/Either'
import { pipe } from 'fp-ts/lib/pipeable'
import * as R from 'ramda'
import * as yargs from 'yargs'

import { Client } from './pg'
//import { schemaClient } from './schema'
import { describeStatement } from './describe'
import { validateStatement, generateTypeScript } from './codegen'

function parseArgs() {
  return yargs
    .usage('Usage: $0 [options] DIRECTORY...')
    .option('d', {
      alias: 'database',
      type: 'string',
      describe:
        'Database URI to connect to, e.g. -d postgres://user:pass@localhost/mydb',
    })
    .option('e', {
      alias: 'ext',
      type: 'string',
      describe: 'File extensions to consider, e.g. -e sql,psql',
      default: 'sql',
    })
    .epilogue(
      `\
Generate TypeScript functions for SQL statements in all files in the \
given directories. For each input file, the output file name is \
generated by removing the file extension and appending ".ts".

Each output file will export a single function whose name is a \
camelCased version of the basename of the input file.

$0 connects to the database to infer the parameter and output column \
types of each SQL statement. It does this without actually executing \
the SQL queries, so it's safe to run against any database.
`
    )
    .help().argv
}

async function main(): Promise<number> {
  const args = parseArgs()
  if (!args._.length) {
    console.error('No input files. Try with `--help`.')
    return 1
  }

  const dirPaths: string[] = []
  for (let dirPath of args._) {
    if (!(await fs.stat(dirPath)).isDirectory()) {
      console.error(`Not a directory: ${dirPath}`)
      return 1
    }
    dirPaths.push(dirPath)
  }

  const fileExtensions = extensions(args.e)

  const client = new Client(args.d ? { connectionString: args.d } : undefined)
  try {
    await client.connect()
  } catch (err) {
    console.error(`Error connecting to database: ${err.message}`)
    return 1
  }

  for (let dirPath of dirPaths) {
    const success = await processDirectory(client, dirPath, fileExtensions)
    if (!success) break
  }

  await client.end()
  return 0
}

async function processDirectory(
  client: Client,
  dirPath: string,
  fileExtensions: string[]
): Promise<boolean> {
  for (let dirent of await fs.readdir(dirPath, {
    encoding: 'utf-8',
    withFileTypes: true,
  })) {
    const fileName = dirent.name
    if (!dirent.isFile() || !hasOneOfExtensions(fileExtensions, fileName))
      continue

    const filePath = path.join(dirPath, fileName)
    if (!(await processSQLFile(client, filePath))) return false
  }
  return true
}

async function processSQLFile(
  client: Client,
  filePath: string
): Promise<boolean> {
  const tsPath = getOutputPath(filePath)
  console.log(`${filePath} => ${tsPath}`)

  const sql = (await fs.readFile(filePath)).toString('utf-8')

  const result = pipe(
    await describeStatement(client, sql),
    chain(validateStatement)
  )

  if (isRight(result)) {
    const tsCode = generateTypeScript(filePath, sql, result.right)
    await fs.writeFile(tsPath, tsCode)
    return true
  }

  console.error(underlined(`Error processing ${filePath}`))
  console.error(result.left)
  return false
}

function getOutputPath(filePath: string): string {
  return path.format({
    ...path.parse(filePath),
    base: undefined,
    ext: '.ts',
  })
}

function extensions(e: string): string[] {
  return e.split(',').map(ext => `.${ext}`)
}

function hasOneOfExtensions(extensions: string[], fileName: string): boolean {
  return extensions.includes(path.parse(fileName).ext)
}

function underlined(str: string): string {
  return str + '\n' + R.repeat('=', str.length).join('')
}

main()
  .then(status => process.exit(status))
  .catch(err => {
    console.error(err)
    process.exit(99)
  })
