import * as fs from 'fs'
import * as path from 'path'
import { promisify } from 'util'

import { isRight } from 'fp-ts/lib/Either'
import * as R from 'ramda'
import * as yargs from 'yargs'

import { Client } from './pg'
//import { schemaClient } from './schema'
import { describeStatement } from './describe'
import { generateTypeScript } from './codegen'

function parseArgs() {
  return yargs
    .usage('Usage: $0 [options] [file|dir]...')
    .epilogue(
      `\
Generate TypeScript functions for SQL statements in the given files, \
or all files under the given directories.

For each input file, the output file name is generated by removing the \
file extension and appending ".ts".

Each output file will export a single function whose name is a camelCased \
version of the basename of the input file.
`
    )
    .option('d', {
      alias: 'database',
      type: 'string',
      describe:
        'Database URI to connect to, e.g. postgres://user:pass@localhost/mydb',
    })
    .help().argv
}

async function main(): Promise<number> {
  const args = parseArgs()

  const client = new Client(args.d ? { connectionString: args.d } : undefined)

  const filePaths = R.flatten(
    args._.map(filePath => {
      const stats = fs.statSync(filePath)
      if (!stats.isFile()) {
        process.stderr.write(`Not a file: ${path}`)
      }
      return [filePath]
    })
  )

  if (!filePaths.length) {
    console.error('No input files. Try with `--help`.')
    return 1
  }

  try {
    await client.connect()
  } catch (err) {
    console.error(`Error connecting to database: ${err.message}`)
    return 1
  }

  for (let filePath of filePaths) {
    const success = await processSQLFile(client, filePath)
    if (!success) break
  }

  await client.end()
  return 0
}

async function processSQLFile(
  client: Client,
  filePath: string
): Promise<boolean> {
  const tsPath = getOutputPath(filePath)
  console.log(`${filePath} => ${tsPath}`)
  const sql = (await promisify(fs.readFile)(filePath)).toString('utf-8')

  const result = await describeStatement(client, sql)

  if (isRight(result)) {
    const tsCode = generateTypeScript(filePath, result.right)
    await promisify(fs.writeFile)(tsPath, tsCode)
    return true
  }

  console.error(underlined(`Error processing ${filePath}`))
  console.error(result.left)
  return false
}

function getOutputPath(filePath: string): string {
  return path.format({
    ...path.parse(filePath),
    base: undefined,
    ext: '.ts',
  })
}

function underlined(str: string): string {
  return str + '\n' + R.repeat('=', str.length).join('')
}

main()
  .then(status => process.exit(status))
  .catch(err => {
    console.error(err)
    process.exit(99)
  })
